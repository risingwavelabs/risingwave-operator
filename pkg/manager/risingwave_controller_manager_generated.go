//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
 * Copyright 2023 RisingWave Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Code generated by ctrlkit. DO NOT EDIT.

package manager

import (
	"context"
	"fmt"

	"github.com/go-logr/logr"
	appsv1alpha1 "github.com/openkruise/kruise-api/apps/v1alpha1"
	appsv1beta1 "github.com/openkruise/kruise-api/apps/v1beta1"
	monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"

	risingwavev1alpha1 "github.com/risingwavelabs/risingwave-operator/apis/risingwave/v1alpha1"
	"github.com/risingwavelabs/risingwave-operator/pkg/ctrlkit"
)

// RisingWaveControllerManagerState is the state manager of RisingWaveControllerManager.
type RisingWaveControllerManagerState struct {
	client.Reader
	target *risingwavev1alpha1.RisingWave
}

// GetCompactorCloneSets lists compactorCloneSets with the following selectors:
//   - labels/risingwave/component=compactor
//   - labels/risingwave/name=${target.Name}
//   - owned
func (s *RisingWaveControllerManagerState) GetCompactorCloneSets(ctx context.Context) ([]appsv1alpha1.CloneSet, error) {
	var compactorCloneSetsList appsv1alpha1.CloneSetList

	matchingLabels := map[string]string{
		"risingwave/component": "compactor",
		"risingwave/name":      s.target.Name,
	}

	err := s.List(ctx, &compactorCloneSetsList, client.InNamespace(s.target.Namespace),
		client.MatchingLabels(matchingLabels))
	if err != nil {
		return nil, fmt.Errorf("unable to get state 'compactorCloneSets': %w", err)
	}

	var validated []appsv1alpha1.CloneSet
	for _, obj := range compactorCloneSetsList.Items {
		if ctrlkit.ValidateOwnership(&obj, s.target) {
			validated = append(validated, obj)
		}
	}

	return validated, nil
}

// GetCompactorDeployments lists compactorDeployments with the following selectors:
//   - labels/risingwave/component=compactor
//   - labels/risingwave/name=${target.Name}
//   - owned
func (s *RisingWaveControllerManagerState) GetCompactorDeployments(ctx context.Context) ([]appsv1.Deployment, error) {
	var compactorDeploymentsList appsv1.DeploymentList

	matchingLabels := map[string]string{
		"risingwave/component": "compactor",
		"risingwave/name":      s.target.Name,
	}

	err := s.List(ctx, &compactorDeploymentsList, client.InNamespace(s.target.Namespace),
		client.MatchingLabels(matchingLabels))
	if err != nil {
		return nil, fmt.Errorf("unable to get state 'compactorDeployments': %w", err)
	}

	var validated []appsv1.Deployment
	for _, obj := range compactorDeploymentsList.Items {
		if ctrlkit.ValidateOwnership(&obj, s.target) {
			validated = append(validated, obj)
		}
	}

	return validated, nil
}

// GetCompactorService gets compactorService with name equals to ${target.Name}-compactor.
func (s *RisingWaveControllerManagerState) GetCompactorService(ctx context.Context) (*corev1.Service, error) {
	var compactorService corev1.Service

	err := s.Get(ctx, types.NamespacedName{
		Namespace: s.target.Namespace,
		Name:      s.target.Name + "-compactor",
	}, &compactorService)
	if err != nil {
		if apierrors.IsNotFound(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("unable to get state 'compactorService': %w", err)
	}
	if !ctrlkit.ValidateOwnership(&compactorService, s.target) {
		return nil, fmt.Errorf("unable to get state 'compactorService': object not owned by target")
	}

	return &compactorService, nil
}

// GetComputeAdvancedStatefulSets lists computeAdvancedStatefulSets with the following selectors:
//   - labels/risingwave/component=compute
//   - labels/risingwave/name=${target.Name}
//   - owned
func (s *RisingWaveControllerManagerState) GetComputeAdvancedStatefulSets(ctx context.Context) ([]appsv1beta1.StatefulSet, error) {
	var computeAdvancedStatefulSetsList appsv1beta1.StatefulSetList

	matchingLabels := map[string]string{
		"risingwave/component": "compute",
		"risingwave/name":      s.target.Name,
	}

	err := s.List(ctx, &computeAdvancedStatefulSetsList, client.InNamespace(s.target.Namespace),
		client.MatchingLabels(matchingLabels))
	if err != nil {
		return nil, fmt.Errorf("unable to get state 'computeAdvancedStatefulSets': %w", err)
	}

	var validated []appsv1beta1.StatefulSet
	for _, obj := range computeAdvancedStatefulSetsList.Items {
		if ctrlkit.ValidateOwnership(&obj, s.target) {
			validated = append(validated, obj)
		}
	}

	return validated, nil
}

// GetComputeService gets computeService with name equals to ${target.Name}-compute.
func (s *RisingWaveControllerManagerState) GetComputeService(ctx context.Context) (*corev1.Service, error) {
	var computeService corev1.Service

	err := s.Get(ctx, types.NamespacedName{
		Namespace: s.target.Namespace,
		Name:      s.target.Name + "-compute",
	}, &computeService)
	if err != nil {
		if apierrors.IsNotFound(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("unable to get state 'computeService': %w", err)
	}
	if !ctrlkit.ValidateOwnership(&computeService, s.target) {
		return nil, fmt.Errorf("unable to get state 'computeService': object not owned by target")
	}

	return &computeService, nil
}

// GetComputeStatefulSets lists computeStatefulSets with the following selectors:
//   - labels/risingwave/component=compute
//   - labels/risingwave/name=${target.Name}
//   - owned
func (s *RisingWaveControllerManagerState) GetComputeStatefulSets(ctx context.Context) ([]appsv1.StatefulSet, error) {
	var computeStatefulSetsList appsv1.StatefulSetList

	matchingLabels := map[string]string{
		"risingwave/component": "compute",
		"risingwave/name":      s.target.Name,
	}

	err := s.List(ctx, &computeStatefulSetsList, client.InNamespace(s.target.Namespace),
		client.MatchingLabels(matchingLabels))
	if err != nil {
		return nil, fmt.Errorf("unable to get state 'computeStatefulSets': %w", err)
	}

	var validated []appsv1.StatefulSet
	for _, obj := range computeStatefulSetsList.Items {
		if ctrlkit.ValidateOwnership(&obj, s.target) {
			validated = append(validated, obj)
		}
	}

	return validated, nil
}

// GetConfigConfigMap gets configConfigMap with name equals to ${target.Name}-default-config.
func (s *RisingWaveControllerManagerState) GetConfigConfigMap(ctx context.Context) (*corev1.ConfigMap, error) {
	var configConfigMap corev1.ConfigMap

	err := s.Get(ctx, types.NamespacedName{
		Namespace: s.target.Namespace,
		Name:      s.target.Name + "-default-config",
	}, &configConfigMap)
	if err != nil {
		if apierrors.IsNotFound(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("unable to get state 'configConfigMap': %w", err)
	}
	if !ctrlkit.ValidateOwnership(&configConfigMap, s.target) {
		return nil, fmt.Errorf("unable to get state 'configConfigMap': object not owned by target")
	}

	return &configConfigMap, nil
}

// GetConnectorCloneSets lists connectorCloneSets with the following selectors:
//   - labels/risingwave/component=connector
//   - labels/risingwave/name=${target.Name}
//   - owned
func (s *RisingWaveControllerManagerState) GetConnectorCloneSets(ctx context.Context) ([]appsv1alpha1.CloneSet, error) {
	var connectorCloneSetsList appsv1alpha1.CloneSetList

	matchingLabels := map[string]string{
		"risingwave/component": "connector",
		"risingwave/name":      s.target.Name,
	}

	err := s.List(ctx, &connectorCloneSetsList, client.InNamespace(s.target.Namespace),
		client.MatchingLabels(matchingLabels))
	if err != nil {
		return nil, fmt.Errorf("unable to get state 'connectorCloneSets': %w", err)
	}

	var validated []appsv1alpha1.CloneSet
	for _, obj := range connectorCloneSetsList.Items {
		if ctrlkit.ValidateOwnership(&obj, s.target) {
			validated = append(validated, obj)
		}
	}

	return validated, nil
}

// GetConnectorDeployments lists connectorDeployments with the following selectors:
//   - labels/risingwave/component=connector
//   - labels/risingwave/name=${target.Name}
//   - owned
func (s *RisingWaveControllerManagerState) GetConnectorDeployments(ctx context.Context) ([]appsv1.Deployment, error) {
	var connectorDeploymentsList appsv1.DeploymentList

	matchingLabels := map[string]string{
		"risingwave/component": "connector",
		"risingwave/name":      s.target.Name,
	}

	err := s.List(ctx, &connectorDeploymentsList, client.InNamespace(s.target.Namespace),
		client.MatchingLabels(matchingLabels))
	if err != nil {
		return nil, fmt.Errorf("unable to get state 'connectorDeployments': %w", err)
	}

	var validated []appsv1.Deployment
	for _, obj := range connectorDeploymentsList.Items {
		if ctrlkit.ValidateOwnership(&obj, s.target) {
			validated = append(validated, obj)
		}
	}

	return validated, nil
}

// GetConnectorService gets connectorService with name equals to ${target.Name}-connector.
func (s *RisingWaveControllerManagerState) GetConnectorService(ctx context.Context) (*corev1.Service, error) {
	var connectorService corev1.Service

	err := s.Get(ctx, types.NamespacedName{
		Namespace: s.target.Namespace,
		Name:      s.target.Name + "-connector",
	}, &connectorService)
	if err != nil {
		if apierrors.IsNotFound(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("unable to get state 'connectorService': %w", err)
	}
	if !ctrlkit.ValidateOwnership(&connectorService, s.target) {
		return nil, fmt.Errorf("unable to get state 'connectorService': object not owned by target")
	}

	return &connectorService, nil
}

// GetFrontendCloneSets lists frontendCloneSets with the following selectors:
//   - labels/risingwave/component=frontend
//   - labels/risingwave/name=${target.Name}
//   - owned
func (s *RisingWaveControllerManagerState) GetFrontendCloneSets(ctx context.Context) ([]appsv1alpha1.CloneSet, error) {
	var frontendCloneSetsList appsv1alpha1.CloneSetList

	matchingLabels := map[string]string{
		"risingwave/component": "frontend",
		"risingwave/name":      s.target.Name,
	}

	err := s.List(ctx, &frontendCloneSetsList, client.InNamespace(s.target.Namespace),
		client.MatchingLabels(matchingLabels))
	if err != nil {
		return nil, fmt.Errorf("unable to get state 'frontendCloneSets': %w", err)
	}

	var validated []appsv1alpha1.CloneSet
	for _, obj := range frontendCloneSetsList.Items {
		if ctrlkit.ValidateOwnership(&obj, s.target) {
			validated = append(validated, obj)
		}
	}

	return validated, nil
}

// GetFrontendDeployments lists frontendDeployments with the following selectors:
//   - labels/risingwave/component=frontend
//   - labels/risingwave/name=${target.Name}
//   - owned
func (s *RisingWaveControllerManagerState) GetFrontendDeployments(ctx context.Context) ([]appsv1.Deployment, error) {
	var frontendDeploymentsList appsv1.DeploymentList

	matchingLabels := map[string]string{
		"risingwave/component": "frontend",
		"risingwave/name":      s.target.Name,
	}

	err := s.List(ctx, &frontendDeploymentsList, client.InNamespace(s.target.Namespace),
		client.MatchingLabels(matchingLabels))
	if err != nil {
		return nil, fmt.Errorf("unable to get state 'frontendDeployments': %w", err)
	}

	var validated []appsv1.Deployment
	for _, obj := range frontendDeploymentsList.Items {
		if ctrlkit.ValidateOwnership(&obj, s.target) {
			validated = append(validated, obj)
		}
	}

	return validated, nil
}

// GetFrontendService gets frontendService with name equals to ${target.Name}-frontend.
func (s *RisingWaveControllerManagerState) GetFrontendService(ctx context.Context) (*corev1.Service, error) {
	var frontendService corev1.Service

	err := s.Get(ctx, types.NamespacedName{
		Namespace: s.target.Namespace,
		Name:      s.target.Name + "-frontend",
	}, &frontendService)
	if err != nil {
		if apierrors.IsNotFound(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("unable to get state 'frontendService': %w", err)
	}
	if !ctrlkit.ValidateOwnership(&frontendService, s.target) {
		return nil, fmt.Errorf("unable to get state 'frontendService': object not owned by target")
	}

	return &frontendService, nil
}

// GetMetaAdvancedStatefulSets lists metaAdvancedStatefulSets with the following selectors:
//   - labels/risingwave/component=meta
//   - labels/risingwave/name=${target.Name}
//   - owned
func (s *RisingWaveControllerManagerState) GetMetaAdvancedStatefulSets(ctx context.Context) ([]appsv1beta1.StatefulSet, error) {
	var metaAdvancedStatefulSetsList appsv1beta1.StatefulSetList

	matchingLabels := map[string]string{
		"risingwave/component": "meta",
		"risingwave/name":      s.target.Name,
	}

	err := s.List(ctx, &metaAdvancedStatefulSetsList, client.InNamespace(s.target.Namespace),
		client.MatchingLabels(matchingLabels))
	if err != nil {
		return nil, fmt.Errorf("unable to get state 'metaAdvancedStatefulSets': %w", err)
	}

	var validated []appsv1beta1.StatefulSet
	for _, obj := range metaAdvancedStatefulSetsList.Items {
		if ctrlkit.ValidateOwnership(&obj, s.target) {
			validated = append(validated, obj)
		}
	}

	return validated, nil
}

// GetMetaService gets metaService with name equals to ${target.Name}-meta.
func (s *RisingWaveControllerManagerState) GetMetaService(ctx context.Context) (*corev1.Service, error) {
	var metaService corev1.Service

	err := s.Get(ctx, types.NamespacedName{
		Namespace: s.target.Namespace,
		Name:      s.target.Name + "-meta",
	}, &metaService)
	if err != nil {
		if apierrors.IsNotFound(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("unable to get state 'metaService': %w", err)
	}
	if !ctrlkit.ValidateOwnership(&metaService, s.target) {
		return nil, fmt.Errorf("unable to get state 'metaService': object not owned by target")
	}

	return &metaService, nil
}

// GetMetaStatefulSets lists metaStatefulSets with the following selectors:
//   - labels/risingwave/component=meta
//   - labels/risingwave/name=${target.Name}
//   - owned
func (s *RisingWaveControllerManagerState) GetMetaStatefulSets(ctx context.Context) ([]appsv1.StatefulSet, error) {
	var metaStatefulSetsList appsv1.StatefulSetList

	matchingLabels := map[string]string{
		"risingwave/component": "meta",
		"risingwave/name":      s.target.Name,
	}

	err := s.List(ctx, &metaStatefulSetsList, client.InNamespace(s.target.Namespace),
		client.MatchingLabels(matchingLabels))
	if err != nil {
		return nil, fmt.Errorf("unable to get state 'metaStatefulSets': %w", err)
	}

	var validated []appsv1.StatefulSet
	for _, obj := range metaStatefulSetsList.Items {
		if ctrlkit.ValidateOwnership(&obj, s.target) {
			validated = append(validated, obj)
		}
	}

	return validated, nil
}

// GetServiceMonitor gets serviceMonitor with name equals to risingwave-${target.Name}.
func (s *RisingWaveControllerManagerState) GetServiceMonitor(ctx context.Context) (*monitoringv1.ServiceMonitor, error) {
	var serviceMonitor monitoringv1.ServiceMonitor

	err := s.Get(ctx, types.NamespacedName{
		Namespace: s.target.Namespace,
		Name:      "risingwave-" + s.target.Name,
	}, &serviceMonitor)
	if err != nil {
		if apierrors.IsNotFound(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("unable to get state 'serviceMonitor': %w", err)
	}
	if !ctrlkit.ValidateOwnership(&serviceMonitor, s.target) {
		return nil, fmt.Errorf("unable to get state 'serviceMonitor': object not owned by target")
	}

	return &serviceMonitor, nil
}

// NewRisingWaveControllerManagerState returns a RisingWaveControllerManagerState (target is not copied).
func NewRisingWaveControllerManagerState(reader client.Reader, target *risingwavev1alpha1.RisingWave) RisingWaveControllerManagerState {
	return RisingWaveControllerManagerState{
		Reader: reader,
		target: target,
	}
}

// RisingWaveControllerManagerImpl declares the implementation interface for RisingWaveControllerManager.
type RisingWaveControllerManagerImpl interface {
	// SyncMetaService creates or updates the service for meta nodes.
	SyncMetaService(ctx context.Context, logger logr.Logger, metaService *corev1.Service) (ctrl.Result, error)

	// SyncMetaStatefulSets creates or updates the StatefulSets for meta nodes.
	SyncMetaStatefulSets(ctx context.Context, logger logr.Logger, metaStatefulSets []appsv1.StatefulSet) (ctrl.Result, error)

	// SyncMetaAdvancedStatefulSets creates or updates the CloneSets for meta nodes.
	SyncMetaAdvancedStatefulSets(ctx context.Context, logger logr.Logger, metaAdvancedStatefulSets []appsv1beta1.StatefulSet) (ctrl.Result, error)

	// WaitBeforeMetaServiceIsAvailable waits (aborts the workflow) before the meta service is available.
	WaitBeforeMetaServiceIsAvailable(ctx context.Context, logger logr.Logger, metaService *corev1.Service) (ctrl.Result, error)

	// WaitBeforeMetaStatefulSetsReady waits (aborts the workflow) before the meta StatefulSets are ready.
	WaitBeforeMetaStatefulSetsReady(ctx context.Context, logger logr.Logger, metaStatefulSets []appsv1.StatefulSet) (ctrl.Result, error)

	// WaitBeforeMetaAdvancedStatefulSetsReady waits (aborts the workflow) before the meta advanced StatefulSets are ready.
	WaitBeforeMetaAdvancedStatefulSetsReady(ctx context.Context, logger logr.Logger, metaAdvancedStatefulSets []appsv1beta1.StatefulSet) (ctrl.Result, error)

	// SyncFrontendService creates or updates the service for frontend nodes.
	SyncFrontendService(ctx context.Context, logger logr.Logger, frontendService *corev1.Service) (ctrl.Result, error)

	// SyncFrontendDeployments creates or updates the Deployments for frontend nodes.
	SyncFrontendDeployments(ctx context.Context, logger logr.Logger, frontendDeployments []appsv1.Deployment) (ctrl.Result, error)

	// SyncFrontendCloneSets creates or updates the Deployments for frontend nodes.
	SyncFrontendCloneSets(ctx context.Context, logger logr.Logger, frontendCloneSets []appsv1alpha1.CloneSet) (ctrl.Result, error)

	// WaitBeforeFrontendDeploymentsReady waits (aborts the workflow) before the frontend Deployments are ready.
	WaitBeforeFrontendDeploymentsReady(ctx context.Context, logger logr.Logger, frontendDeployments []appsv1.Deployment) (ctrl.Result, error)

	// WaitBeforeFrontendCloneSetsReady waits (aborts the workflow) before the frontend CloneSets are ready.
	WaitBeforeFrontendCloneSetsReady(ctx context.Context, logger logr.Logger, frontendCloneSets []appsv1alpha1.CloneSet) (ctrl.Result, error)

	// SyncComputeService creates or updates the service for compute nodes.
	SyncComputeService(ctx context.Context, logger logr.Logger, computeService *corev1.Service) (ctrl.Result, error)

	// SyncComputeStatefulSets creates or updates the StatefulSets for compute nodes.
	SyncComputeStatefulSets(ctx context.Context, logger logr.Logger, computeStatefulSets []appsv1.StatefulSet) (ctrl.Result, error)

	// SyncComputeAdvancedStatefulSets creates or updates the StatefulSets for compute nodes.
	SyncComputeAdvancedStatefulSets(ctx context.Context, logger logr.Logger, computeAdvancedStatefulSets []appsv1beta1.StatefulSet) (ctrl.Result, error)

	// WaitBeforeComputeStatefulSetsReady waits (aborts the workflow) before the compute StatefulSets are ready.
	WaitBeforeComputeStatefulSetsReady(ctx context.Context, logger logr.Logger, computeStatefulSets []appsv1.StatefulSet) (ctrl.Result, error)

	// WaitBeforeComputeStatefulSetsReady waits (aborts the workflow) before the compute advanced StatefulSets are ready.
	WaitBeforeComputeAdvancedStatefulSetsReady(ctx context.Context, logger logr.Logger, computeAdvancedStatefulSets []appsv1beta1.StatefulSet) (ctrl.Result, error)

	// SyncCompactorService creates or updates the service for compactor nodes.
	SyncCompactorService(ctx context.Context, logger logr.Logger, compactorService *corev1.Service) (ctrl.Result, error)

	// SyncCompactorDeployments creates or updates the Deployments for compactor nodes.
	SyncCompactorDeployments(ctx context.Context, logger logr.Logger, compactorDeployments []appsv1.Deployment) (ctrl.Result, error)

	// SyncCompactorCloneSets creates or updates the Deployments for compactor nodes.
	SyncCompactorCloneSets(ctx context.Context, logger logr.Logger, compactorCloneSets []appsv1alpha1.CloneSet) (ctrl.Result, error)

	// WaitBeforeCompactorDeploymentsReady waits (aborts the workflow) before the compactor Deployments are ready.
	WaitBeforeCompactorDeploymentsReady(ctx context.Context, logger logr.Logger, compactorDeployments []appsv1.Deployment) (ctrl.Result, error)

	// WaitBeforeCompactorDeploymentsReady waits (aborts the workflow) before the compactor CloneSets are ready.
	WaitBeforeCompactorCloneSetsReady(ctx context.Context, logger logr.Logger, compactorCloneSets []appsv1alpha1.CloneSet) (ctrl.Result, error)

	// SyncConnectorService creates or updates the service for connector nodes.
	SyncConnectorService(ctx context.Context, logger logr.Logger, connectorService *corev1.Service) (ctrl.Result, error)

	// SyncConnectorDeployments creates or updates the Deployments for connector nodes.
	SyncConnectorDeployments(ctx context.Context, logger logr.Logger, connectorDeployments []appsv1.Deployment) (ctrl.Result, error)

	// SyncConnectorCloneSets creates or updates the Deployments for connector nodes.
	SyncConnectorCloneSets(ctx context.Context, logger logr.Logger, connectorCloneSets []appsv1alpha1.CloneSet) (ctrl.Result, error)

	// WaitBeforeConnectorDeploymentsReady waits (aborts the workflow) before the connector Deployments are ready.
	WaitBeforeConnectorDeploymentsReady(ctx context.Context, logger logr.Logger, connectorDeployments []appsv1.Deployment) (ctrl.Result, error)

	// WaitBeforeConnectorDeploymentsReady waits (aborts the workflow) before the connector CloneSets are ready.
	WaitBeforeConnectorCloneSetsReady(ctx context.Context, logger logr.Logger, connectorCloneSets []appsv1alpha1.CloneSet) (ctrl.Result, error)

	// SyncConfigConfigMap creates or updates the configmap for RisingWave configs.
	SyncConfigConfigMap(ctx context.Context, logger logr.Logger, configConfigMap *corev1.ConfigMap) (ctrl.Result, error)

	// SyncServiceMonitor creates or updates the service monitor for RisingWave.
	SyncServiceMonitor(ctx context.Context, logger logr.Logger, serviceMonitor *monitoringv1.ServiceMonitor) (ctrl.Result, error)

	// CollectRunningStatisticsAndSyncStatus collects running statistics and sync them into the status.
	CollectRunningStatisticsAndSyncStatus(ctx context.Context, logger logr.Logger, frontendService *corev1.Service, metaService *corev1.Service, computeService *corev1.Service, compactorService *corev1.Service, connectorService *corev1.Service, metaStatefulSets []appsv1.StatefulSet, frontendDeployments []appsv1.Deployment, computeStatefulSets []appsv1.StatefulSet, compactorDeployments []appsv1.Deployment, connectorDeployments []appsv1.Deployment, configConfigMap *corev1.ConfigMap) (ctrl.Result, error)

	CollectOpenKruiseRunningStatisticsAndSyncStatus(ctx context.Context, logger logr.Logger, frontendService *corev1.Service, metaService *corev1.Service, computeService *corev1.Service, compactorService *corev1.Service, connectorService *corev1.Service, metaAdvancedStatefulSets []appsv1beta1.StatefulSet, frontendCloneSets []appsv1alpha1.CloneSet, computeAdvancedStatefulSets []appsv1beta1.StatefulSet, compactorCloneSets []appsv1alpha1.CloneSet, connectorCloneSets []appsv1alpha1.CloneSet, configConfigMap *corev1.ConfigMap) (ctrl.Result, error)
}

// Pre-defined actions in RisingWaveControllerManager.
const (
	RisingWaveAction_SyncMetaService                                 = "SyncMetaService"
	RisingWaveAction_SyncMetaStatefulSets                            = "SyncMetaStatefulSets"
	RisingWaveAction_SyncMetaAdvancedStatefulSets                    = "SyncMetaAdvancedStatefulSets"
	RisingWaveAction_WaitBeforeMetaServiceIsAvailable                = "WaitBeforeMetaServiceIsAvailable"
	RisingWaveAction_WaitBeforeMetaStatefulSetsReady                 = "WaitBeforeMetaStatefulSetsReady"
	RisingWaveAction_WaitBeforeMetaAdvancedStatefulSetsReady         = "WaitBeforeMetaAdvancedStatefulSetsReady"
	RisingWaveAction_SyncFrontendService                             = "SyncFrontendService"
	RisingWaveAction_SyncFrontendDeployments                         = "SyncFrontendDeployments"
	RisingWaveAction_SyncFrontendCloneSets                           = "SyncFrontendCloneSets"
	RisingWaveAction_WaitBeforeFrontendDeploymentsReady              = "WaitBeforeFrontendDeploymentsReady"
	RisingWaveAction_WaitBeforeFrontendCloneSetsReady                = "WaitBeforeFrontendCloneSetsReady"
	RisingWaveAction_SyncComputeService                              = "SyncComputeService"
	RisingWaveAction_SyncComputeStatefulSets                         = "SyncComputeStatefulSets"
	RisingWaveAction_SyncComputeAdvancedStatefulSets                 = "SyncComputeAdvancedStatefulSets"
	RisingWaveAction_WaitBeforeComputeStatefulSetsReady              = "WaitBeforeComputeStatefulSetsReady"
	RisingWaveAction_WaitBeforeComputeAdvancedStatefulSetsReady      = "WaitBeforeComputeAdvancedStatefulSetsReady"
	RisingWaveAction_SyncCompactorService                            = "SyncCompactorService"
	RisingWaveAction_SyncCompactorDeployments                        = "SyncCompactorDeployments"
	RisingWaveAction_SyncCompactorCloneSets                          = "SyncCompactorCloneSets"
	RisingWaveAction_WaitBeforeCompactorDeploymentsReady             = "WaitBeforeCompactorDeploymentsReady"
	RisingWaveAction_WaitBeforeCompactorCloneSetsReady               = "WaitBeforeCompactorCloneSetsReady"
	RisingWaveAction_SyncConnectorService                            = "SyncConnectorService"
	RisingWaveAction_SyncConnectorDeployments                        = "SyncConnectorDeployments"
	RisingWaveAction_SyncConnectorCloneSets                          = "SyncConnectorCloneSets"
	RisingWaveAction_WaitBeforeConnectorDeploymentsReady             = "WaitBeforeConnectorDeploymentsReady"
	RisingWaveAction_WaitBeforeConnectorCloneSetsReady               = "WaitBeforeConnectorCloneSetsReady"
	RisingWaveAction_SyncConfigConfigMap                             = "SyncConfigConfigMap"
	RisingWaveAction_SyncServiceMonitor                              = "SyncServiceMonitor"
	RisingWaveAction_CollectRunningStatisticsAndSyncStatus           = "CollectRunningStatisticsAndSyncStatus"
	RisingWaveAction_CollectOpenKruiseRunningStatisticsAndSyncStatus = "CollectOpenKruiseRunningStatisticsAndSyncStatus"
)

// RisingWaveControllerManager encapsulates the states and actions used by RisingWaveController.
type RisingWaveControllerManager struct {
	hook   ctrlkit.ActionHook
	state  RisingWaveControllerManagerState
	impl   RisingWaveControllerManagerImpl
	logger logr.Logger
}

// NewAction returns a new action controlled by the manager.
func (m *RisingWaveControllerManager) NewAction(description string, f func(context.Context, logr.Logger) (ctrl.Result, error)) ctrlkit.Action {
	return ctrlkit.NewAction(description, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", description)

		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, description, result, err) }()
			m.hook.PreRun(ctx, logger, description, nil)
		}

		return f(ctx, logger)
	})
}

// SyncMetaService generates the action of "SyncMetaService".
func (m *RisingWaveControllerManager) SyncMetaService() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_SyncMetaService, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_SyncMetaService)

		// Get states.
		metaService, err := m.state.GetMetaService(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_SyncMetaService, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_SyncMetaService, map[string]runtime.Object{
				"metaService": metaService,
			})
		}

		return m.impl.SyncMetaService(ctx, logger, metaService)
	})
}

// SyncMetaStatefulSets generates the action of "SyncMetaStatefulSets".
func (m *RisingWaveControllerManager) SyncMetaStatefulSets() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_SyncMetaStatefulSets, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_SyncMetaStatefulSets)

		// Get states.
		metaStatefulSets, err := m.state.GetMetaStatefulSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_SyncMetaStatefulSets, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_SyncMetaStatefulSets, map[string]runtime.Object{
				"metaStatefulSets": &appsv1.StatefulSetList{Items: metaStatefulSets},
			})
		}

		return m.impl.SyncMetaStatefulSets(ctx, logger, metaStatefulSets)
	})
}

// SyncMetaAdvancedStatefulSets generates the action of "SyncMetaAdvancedStatefulSets".
func (m *RisingWaveControllerManager) SyncMetaAdvancedStatefulSets() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_SyncMetaAdvancedStatefulSets, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_SyncMetaAdvancedStatefulSets)

		// Get states.
		metaAdvancedStatefulSets, err := m.state.GetMetaAdvancedStatefulSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_SyncMetaAdvancedStatefulSets, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_SyncMetaAdvancedStatefulSets, map[string]runtime.Object{
				"metaAdvancedStatefulSets": &appsv1beta1.StatefulSetList{Items: metaAdvancedStatefulSets},
			})
		}

		return m.impl.SyncMetaAdvancedStatefulSets(ctx, logger, metaAdvancedStatefulSets)
	})
}

// WaitBeforeMetaServiceIsAvailable generates the action of "WaitBeforeMetaServiceIsAvailable".
func (m *RisingWaveControllerManager) WaitBeforeMetaServiceIsAvailable() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_WaitBeforeMetaServiceIsAvailable, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_WaitBeforeMetaServiceIsAvailable)

		// Get states.
		metaService, err := m.state.GetMetaService(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_WaitBeforeMetaServiceIsAvailable, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_WaitBeforeMetaServiceIsAvailable, map[string]runtime.Object{
				"metaService": metaService,
			})
		}

		return m.impl.WaitBeforeMetaServiceIsAvailable(ctx, logger, metaService)
	})
}

// WaitBeforeMetaStatefulSetsReady generates the action of "WaitBeforeMetaStatefulSetsReady".
func (m *RisingWaveControllerManager) WaitBeforeMetaStatefulSetsReady() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_WaitBeforeMetaStatefulSetsReady, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_WaitBeforeMetaStatefulSetsReady)

		// Get states.
		metaStatefulSets, err := m.state.GetMetaStatefulSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_WaitBeforeMetaStatefulSetsReady, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_WaitBeforeMetaStatefulSetsReady, map[string]runtime.Object{
				"metaStatefulSets": &appsv1.StatefulSetList{Items: metaStatefulSets},
			})
		}

		return m.impl.WaitBeforeMetaStatefulSetsReady(ctx, logger, metaStatefulSets)
	})
}

// WaitBeforeMetaAdvancedStatefulSetsReady generates the action of "WaitBeforeMetaAdvancedStatefulSetsReady".
func (m *RisingWaveControllerManager) WaitBeforeMetaAdvancedStatefulSetsReady() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_WaitBeforeMetaAdvancedStatefulSetsReady, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_WaitBeforeMetaAdvancedStatefulSetsReady)

		// Get states.
		metaAdvancedStatefulSets, err := m.state.GetMetaAdvancedStatefulSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() {
				m.hook.PostRun(ctx, logger, RisingWaveAction_WaitBeforeMetaAdvancedStatefulSetsReady, result, err)
			}()
			m.hook.PreRun(ctx, logger, RisingWaveAction_WaitBeforeMetaAdvancedStatefulSetsReady, map[string]runtime.Object{
				"metaAdvancedStatefulSets": &appsv1beta1.StatefulSetList{Items: metaAdvancedStatefulSets},
			})
		}

		return m.impl.WaitBeforeMetaAdvancedStatefulSetsReady(ctx, logger, metaAdvancedStatefulSets)
	})
}

// SyncFrontendService generates the action of "SyncFrontendService".
func (m *RisingWaveControllerManager) SyncFrontendService() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_SyncFrontendService, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_SyncFrontendService)

		// Get states.
		frontendService, err := m.state.GetFrontendService(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_SyncFrontendService, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_SyncFrontendService, map[string]runtime.Object{
				"frontendService": frontendService,
			})
		}

		return m.impl.SyncFrontendService(ctx, logger, frontendService)
	})
}

// SyncFrontendDeployments generates the action of "SyncFrontendDeployments".
func (m *RisingWaveControllerManager) SyncFrontendDeployments() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_SyncFrontendDeployments, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_SyncFrontendDeployments)

		// Get states.
		frontendDeployments, err := m.state.GetFrontendDeployments(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_SyncFrontendDeployments, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_SyncFrontendDeployments, map[string]runtime.Object{
				"frontendDeployments": &appsv1.DeploymentList{Items: frontendDeployments},
			})
		}

		return m.impl.SyncFrontendDeployments(ctx, logger, frontendDeployments)
	})
}

// SyncFrontendCloneSets generates the action of "SyncFrontendCloneSets".
func (m *RisingWaveControllerManager) SyncFrontendCloneSets() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_SyncFrontendCloneSets, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_SyncFrontendCloneSets)

		// Get states.
		frontendCloneSets, err := m.state.GetFrontendCloneSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_SyncFrontendCloneSets, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_SyncFrontendCloneSets, map[string]runtime.Object{
				"frontendCloneSets": &appsv1alpha1.CloneSetList{Items: frontendCloneSets},
			})
		}

		return m.impl.SyncFrontendCloneSets(ctx, logger, frontendCloneSets)
	})
}

// WaitBeforeFrontendDeploymentsReady generates the action of "WaitBeforeFrontendDeploymentsReady".
func (m *RisingWaveControllerManager) WaitBeforeFrontendDeploymentsReady() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_WaitBeforeFrontendDeploymentsReady, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_WaitBeforeFrontendDeploymentsReady)

		// Get states.
		frontendDeployments, err := m.state.GetFrontendDeployments(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_WaitBeforeFrontendDeploymentsReady, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_WaitBeforeFrontendDeploymentsReady, map[string]runtime.Object{
				"frontendDeployments": &appsv1.DeploymentList{Items: frontendDeployments},
			})
		}

		return m.impl.WaitBeforeFrontendDeploymentsReady(ctx, logger, frontendDeployments)
	})
}

// WaitBeforeFrontendCloneSetsReady generates the action of "WaitBeforeFrontendCloneSetsReady".
func (m *RisingWaveControllerManager) WaitBeforeFrontendCloneSetsReady() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_WaitBeforeFrontendCloneSetsReady, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_WaitBeforeFrontendCloneSetsReady)

		// Get states.
		frontendCloneSets, err := m.state.GetFrontendCloneSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_WaitBeforeFrontendCloneSetsReady, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_WaitBeforeFrontendCloneSetsReady, map[string]runtime.Object{
				"frontendCloneSets": &appsv1alpha1.CloneSetList{Items: frontendCloneSets},
			})
		}

		return m.impl.WaitBeforeFrontendCloneSetsReady(ctx, logger, frontendCloneSets)
	})
}

// SyncComputeService generates the action of "SyncComputeService".
func (m *RisingWaveControllerManager) SyncComputeService() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_SyncComputeService, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_SyncComputeService)

		// Get states.
		computeService, err := m.state.GetComputeService(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_SyncComputeService, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_SyncComputeService, map[string]runtime.Object{
				"computeService": computeService,
			})
		}

		return m.impl.SyncComputeService(ctx, logger, computeService)
	})
}

// SyncComputeStatefulSets generates the action of "SyncComputeStatefulSets".
func (m *RisingWaveControllerManager) SyncComputeStatefulSets() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_SyncComputeStatefulSets, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_SyncComputeStatefulSets)

		// Get states.
		computeStatefulSets, err := m.state.GetComputeStatefulSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_SyncComputeStatefulSets, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_SyncComputeStatefulSets, map[string]runtime.Object{
				"computeStatefulSets": &appsv1.StatefulSetList{Items: computeStatefulSets},
			})
		}

		return m.impl.SyncComputeStatefulSets(ctx, logger, computeStatefulSets)
	})
}

// SyncComputeAdvancedStatefulSets generates the action of "SyncComputeAdvancedStatefulSets".
func (m *RisingWaveControllerManager) SyncComputeAdvancedStatefulSets() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_SyncComputeAdvancedStatefulSets, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_SyncComputeAdvancedStatefulSets)

		// Get states.
		computeAdvancedStatefulSets, err := m.state.GetComputeAdvancedStatefulSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_SyncComputeAdvancedStatefulSets, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_SyncComputeAdvancedStatefulSets, map[string]runtime.Object{
				"computeAdvancedStatefulSets": &appsv1beta1.StatefulSetList{Items: computeAdvancedStatefulSets},
			})
		}

		return m.impl.SyncComputeAdvancedStatefulSets(ctx, logger, computeAdvancedStatefulSets)
	})
}

// WaitBeforeComputeStatefulSetsReady generates the action of "WaitBeforeComputeStatefulSetsReady".
func (m *RisingWaveControllerManager) WaitBeforeComputeStatefulSetsReady() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_WaitBeforeComputeStatefulSetsReady, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_WaitBeforeComputeStatefulSetsReady)

		// Get states.
		computeStatefulSets, err := m.state.GetComputeStatefulSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_WaitBeforeComputeStatefulSetsReady, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_WaitBeforeComputeStatefulSetsReady, map[string]runtime.Object{
				"computeStatefulSets": &appsv1.StatefulSetList{Items: computeStatefulSets},
			})
		}

		return m.impl.WaitBeforeComputeStatefulSetsReady(ctx, logger, computeStatefulSets)
	})
}

// WaitBeforeComputeAdvancedStatefulSetsReady generates the action of "WaitBeforeComputeAdvancedStatefulSetsReady".
func (m *RisingWaveControllerManager) WaitBeforeComputeAdvancedStatefulSetsReady() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_WaitBeforeComputeAdvancedStatefulSetsReady, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_WaitBeforeComputeAdvancedStatefulSetsReady)

		// Get states.
		computeAdvancedStatefulSets, err := m.state.GetComputeAdvancedStatefulSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() {
				m.hook.PostRun(ctx, logger, RisingWaveAction_WaitBeforeComputeAdvancedStatefulSetsReady, result, err)
			}()
			m.hook.PreRun(ctx, logger, RisingWaveAction_WaitBeforeComputeAdvancedStatefulSetsReady, map[string]runtime.Object{
				"computeAdvancedStatefulSets": &appsv1beta1.StatefulSetList{Items: computeAdvancedStatefulSets},
			})
		}

		return m.impl.WaitBeforeComputeAdvancedStatefulSetsReady(ctx, logger, computeAdvancedStatefulSets)
	})
}

// SyncCompactorService generates the action of "SyncCompactorService".
func (m *RisingWaveControllerManager) SyncCompactorService() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_SyncCompactorService, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_SyncCompactorService)

		// Get states.
		compactorService, err := m.state.GetCompactorService(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_SyncCompactorService, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_SyncCompactorService, map[string]runtime.Object{
				"compactorService": compactorService,
			})
		}

		return m.impl.SyncCompactorService(ctx, logger, compactorService)
	})
}

// SyncCompactorDeployments generates the action of "SyncCompactorDeployments".
func (m *RisingWaveControllerManager) SyncCompactorDeployments() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_SyncCompactorDeployments, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_SyncCompactorDeployments)

		// Get states.
		compactorDeployments, err := m.state.GetCompactorDeployments(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_SyncCompactorDeployments, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_SyncCompactorDeployments, map[string]runtime.Object{
				"compactorDeployments": &appsv1.DeploymentList{Items: compactorDeployments},
			})
		}

		return m.impl.SyncCompactorDeployments(ctx, logger, compactorDeployments)
	})
}

// SyncCompactorCloneSets generates the action of "SyncCompactorCloneSets".
func (m *RisingWaveControllerManager) SyncCompactorCloneSets() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_SyncCompactorCloneSets, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_SyncCompactorCloneSets)

		// Get states.
		compactorCloneSets, err := m.state.GetCompactorCloneSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_SyncCompactorCloneSets, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_SyncCompactorCloneSets, map[string]runtime.Object{
				"compactorCloneSets": &appsv1alpha1.CloneSetList{Items: compactorCloneSets},
			})
		}

		return m.impl.SyncCompactorCloneSets(ctx, logger, compactorCloneSets)
	})
}

// WaitBeforeCompactorDeploymentsReady generates the action of "WaitBeforeCompactorDeploymentsReady".
func (m *RisingWaveControllerManager) WaitBeforeCompactorDeploymentsReady() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_WaitBeforeCompactorDeploymentsReady, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_WaitBeforeCompactorDeploymentsReady)

		// Get states.
		compactorDeployments, err := m.state.GetCompactorDeployments(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_WaitBeforeCompactorDeploymentsReady, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_WaitBeforeCompactorDeploymentsReady, map[string]runtime.Object{
				"compactorDeployments": &appsv1.DeploymentList{Items: compactorDeployments},
			})
		}

		return m.impl.WaitBeforeCompactorDeploymentsReady(ctx, logger, compactorDeployments)
	})
}

// WaitBeforeCompactorCloneSetsReady generates the action of "WaitBeforeCompactorCloneSetsReady".
func (m *RisingWaveControllerManager) WaitBeforeCompactorCloneSetsReady() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_WaitBeforeCompactorCloneSetsReady, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_WaitBeforeCompactorCloneSetsReady)

		// Get states.
		compactorCloneSets, err := m.state.GetCompactorCloneSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_WaitBeforeCompactorCloneSetsReady, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_WaitBeforeCompactorCloneSetsReady, map[string]runtime.Object{
				"compactorCloneSets": &appsv1alpha1.CloneSetList{Items: compactorCloneSets},
			})
		}

		return m.impl.WaitBeforeCompactorCloneSetsReady(ctx, logger, compactorCloneSets)
	})
}

// SyncConnectorService generates the action of "SyncConnectorService".
func (m *RisingWaveControllerManager) SyncConnectorService() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_SyncConnectorService, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_SyncConnectorService)

		// Get states.
		connectorService, err := m.state.GetConnectorService(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_SyncConnectorService, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_SyncConnectorService, map[string]runtime.Object{
				"connectorService": connectorService,
			})
		}

		return m.impl.SyncConnectorService(ctx, logger, connectorService)
	})
}

// SyncConnectorDeployments generates the action of "SyncConnectorDeployments".
func (m *RisingWaveControllerManager) SyncConnectorDeployments() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_SyncConnectorDeployments, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_SyncConnectorDeployments)

		// Get states.
		connectorDeployments, err := m.state.GetConnectorDeployments(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_SyncConnectorDeployments, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_SyncConnectorDeployments, map[string]runtime.Object{
				"connectorDeployments": &appsv1.DeploymentList{Items: connectorDeployments},
			})
		}

		return m.impl.SyncConnectorDeployments(ctx, logger, connectorDeployments)
	})
}

// SyncConnectorCloneSets generates the action of "SyncConnectorCloneSets".
func (m *RisingWaveControllerManager) SyncConnectorCloneSets() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_SyncConnectorCloneSets, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_SyncConnectorCloneSets)

		// Get states.
		connectorCloneSets, err := m.state.GetConnectorCloneSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_SyncConnectorCloneSets, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_SyncConnectorCloneSets, map[string]runtime.Object{
				"connectorCloneSets": &appsv1alpha1.CloneSetList{Items: connectorCloneSets},
			})
		}

		return m.impl.SyncConnectorCloneSets(ctx, logger, connectorCloneSets)
	})
}

// WaitBeforeConnectorDeploymentsReady generates the action of "WaitBeforeConnectorDeploymentsReady".
func (m *RisingWaveControllerManager) WaitBeforeConnectorDeploymentsReady() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_WaitBeforeConnectorDeploymentsReady, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_WaitBeforeConnectorDeploymentsReady)

		// Get states.
		connectorDeployments, err := m.state.GetConnectorDeployments(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_WaitBeforeConnectorDeploymentsReady, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_WaitBeforeConnectorDeploymentsReady, map[string]runtime.Object{
				"connectorDeployments": &appsv1.DeploymentList{Items: connectorDeployments},
			})
		}

		return m.impl.WaitBeforeConnectorDeploymentsReady(ctx, logger, connectorDeployments)
	})
}

// WaitBeforeConnectorCloneSetsReady generates the action of "WaitBeforeConnectorCloneSetsReady".
func (m *RisingWaveControllerManager) WaitBeforeConnectorCloneSetsReady() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_WaitBeforeConnectorCloneSetsReady, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_WaitBeforeConnectorCloneSetsReady)

		// Get states.
		connectorCloneSets, err := m.state.GetConnectorCloneSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_WaitBeforeConnectorCloneSetsReady, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_WaitBeforeConnectorCloneSetsReady, map[string]runtime.Object{
				"connectorCloneSets": &appsv1alpha1.CloneSetList{Items: connectorCloneSets},
			})
		}

		return m.impl.WaitBeforeConnectorCloneSetsReady(ctx, logger, connectorCloneSets)
	})
}

// SyncConfigConfigMap generates the action of "SyncConfigConfigMap".
func (m *RisingWaveControllerManager) SyncConfigConfigMap() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_SyncConfigConfigMap, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_SyncConfigConfigMap)

		// Get states.
		configConfigMap, err := m.state.GetConfigConfigMap(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_SyncConfigConfigMap, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_SyncConfigConfigMap, map[string]runtime.Object{
				"configConfigMap": configConfigMap,
			})
		}

		return m.impl.SyncConfigConfigMap(ctx, logger, configConfigMap)
	})
}

// SyncServiceMonitor generates the action of "SyncServiceMonitor".
func (m *RisingWaveControllerManager) SyncServiceMonitor() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_SyncServiceMonitor, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_SyncServiceMonitor)

		// Get states.
		serviceMonitor, err := m.state.GetServiceMonitor(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() { m.hook.PostRun(ctx, logger, RisingWaveAction_SyncServiceMonitor, result, err) }()
			m.hook.PreRun(ctx, logger, RisingWaveAction_SyncServiceMonitor, map[string]runtime.Object{
				"serviceMonitor": serviceMonitor,
			})
		}

		return m.impl.SyncServiceMonitor(ctx, logger, serviceMonitor)
	})
}

// CollectRunningStatisticsAndSyncStatus generates the action of "CollectRunningStatisticsAndSyncStatus".
func (m *RisingWaveControllerManager) CollectRunningStatisticsAndSyncStatus() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_CollectRunningStatisticsAndSyncStatus, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_CollectRunningStatisticsAndSyncStatus)

		// Get states.
		frontendService, err := m.state.GetFrontendService(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		metaService, err := m.state.GetMetaService(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		computeService, err := m.state.GetComputeService(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		compactorService, err := m.state.GetCompactorService(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		connectorService, err := m.state.GetConnectorService(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		metaStatefulSets, err := m.state.GetMetaStatefulSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		frontendDeployments, err := m.state.GetFrontendDeployments(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		computeStatefulSets, err := m.state.GetComputeStatefulSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		compactorDeployments, err := m.state.GetCompactorDeployments(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		connectorDeployments, err := m.state.GetConnectorDeployments(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		configConfigMap, err := m.state.GetConfigConfigMap(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() {
				m.hook.PostRun(ctx, logger, RisingWaveAction_CollectRunningStatisticsAndSyncStatus, result, err)
			}()
			m.hook.PreRun(ctx, logger, RisingWaveAction_CollectRunningStatisticsAndSyncStatus, map[string]runtime.Object{
				"frontendService":      frontendService,
				"metaService":          metaService,
				"computeService":       computeService,
				"compactorService":     compactorService,
				"connectorService":     connectorService,
				"metaStatefulSets":     &appsv1.StatefulSetList{Items: metaStatefulSets},
				"frontendDeployments":  &appsv1.DeploymentList{Items: frontendDeployments},
				"computeStatefulSets":  &appsv1.StatefulSetList{Items: computeStatefulSets},
				"compactorDeployments": &appsv1.DeploymentList{Items: compactorDeployments},
				"connectorDeployments": &appsv1.DeploymentList{Items: connectorDeployments},
				"configConfigMap":      configConfigMap,
			})
		}

		return m.impl.CollectRunningStatisticsAndSyncStatus(ctx, logger, frontendService, metaService, computeService, compactorService, connectorService, metaStatefulSets, frontendDeployments, computeStatefulSets, compactorDeployments, connectorDeployments, configConfigMap)
	})
}

// CollectOpenKruiseRunningStatisticsAndSyncStatus generates the action of "CollectOpenKruiseRunningStatisticsAndSyncStatus".
func (m *RisingWaveControllerManager) CollectOpenKruiseRunningStatisticsAndSyncStatus() ctrlkit.Action {
	return ctrlkit.NewAction(RisingWaveAction_CollectOpenKruiseRunningStatisticsAndSyncStatus, func(ctx context.Context) (result ctrl.Result, err error) {
		logger := m.logger.WithValues("action", RisingWaveAction_CollectOpenKruiseRunningStatisticsAndSyncStatus)

		// Get states.
		frontendService, err := m.state.GetFrontendService(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		metaService, err := m.state.GetMetaService(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		computeService, err := m.state.GetComputeService(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		compactorService, err := m.state.GetCompactorService(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		connectorService, err := m.state.GetConnectorService(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		metaAdvancedStatefulSets, err := m.state.GetMetaAdvancedStatefulSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		frontendCloneSets, err := m.state.GetFrontendCloneSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		computeAdvancedStatefulSets, err := m.state.GetComputeAdvancedStatefulSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		compactorCloneSets, err := m.state.GetCompactorCloneSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		connectorCloneSets, err := m.state.GetConnectorCloneSets(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		configConfigMap, err := m.state.GetConfigConfigMap(ctx)
		if err != nil {
			return ctrlkit.RequeueIfError(err)
		}

		// Invoke action.
		if m.hook != nil {
			defer func() {
				m.hook.PostRun(ctx, logger, RisingWaveAction_CollectOpenKruiseRunningStatisticsAndSyncStatus, result, err)
			}()
			m.hook.PreRun(ctx, logger, RisingWaveAction_CollectOpenKruiseRunningStatisticsAndSyncStatus, map[string]runtime.Object{
				"frontendService":             frontendService,
				"metaService":                 metaService,
				"computeService":              computeService,
				"compactorService":            compactorService,
				"connectorService":            connectorService,
				"metaAdvancedStatefulSets":    &appsv1beta1.StatefulSetList{Items: metaAdvancedStatefulSets},
				"frontendCloneSets":           &appsv1alpha1.CloneSetList{Items: frontendCloneSets},
				"computeAdvancedStatefulSets": &appsv1beta1.StatefulSetList{Items: computeAdvancedStatefulSets},
				"compactorCloneSets":          &appsv1alpha1.CloneSetList{Items: compactorCloneSets},
				"connectorCloneSets":          &appsv1alpha1.CloneSetList{Items: connectorCloneSets},
				"configConfigMap":             configConfigMap,
			})
		}

		return m.impl.CollectOpenKruiseRunningStatisticsAndSyncStatus(ctx, logger, frontendService, metaService, computeService, compactorService, connectorService, metaAdvancedStatefulSets, frontendCloneSets, computeAdvancedStatefulSets, compactorCloneSets, connectorCloneSets, configConfigMap)
	})
}

type RisingWaveControllerManagerOption func(*RisingWaveControllerManager)

func RisingWaveControllerManager_WithActionHook(hook ctrlkit.ActionHook) RisingWaveControllerManagerOption {
	return func(m *RisingWaveControllerManager) {
		m.hook = hook
	}
}

// NewRisingWaveControllerManager returns a new RisingWaveControllerManager with given state and implementation.
func NewRisingWaveControllerManager(state RisingWaveControllerManagerState, impl RisingWaveControllerManagerImpl, logger logr.Logger, opts ...RisingWaveControllerManagerOption) RisingWaveControllerManager {
	m := RisingWaveControllerManager{
		state:  state,
		impl:   impl,
		logger: logger,
	}

	for _, opt := range opts {
		opt(&m)
	}

	return m
}
